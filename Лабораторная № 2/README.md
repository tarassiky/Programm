Лабораторная работа № 2.

1.1: Создайте простое замыкание (closure) в виде внутренней (вложенной) функции внутри обычной функции. Внутренняя функция (замыкание, closure) должна использовать переменные и аргументы обычной функции, в которую она вложена. Внутри внутренней функции (closure) распечатайте переданные аргументы в терминале. Верните вложенную функцию из обычной функции с помощью выражения return.

Результат:

![image](https://github.com/user-attachments/assets/402538e1-f424-46b4-bb94-8c558aef5552)

Программа определяет функцию book, которая создает и возвращает информацию о книге в виде словаря. Внутренняя функция inner_book содержит данные о названии книги, годе издания и авторе. При вызове функции book возвращается словарь с этой информацией, который затем выводится на экран. В данном случае, программа выводит данные о книге "Ночь в Лиссабоне", изданной в 1961 году, автором которой является Эрих Мария Ремарк.

1.2: Изучите на примерах в интернете, что такое closure и и как их применять для создания простого декоратора (decorator) с @-синтаксисом в Python. Модернизируйте калькулятор из задачи 3.1 лабораторной работы №1. Декорируйте вашу функцию calculate. В соответствующем декорирующем замыкании, в сlosure, то есть во внутренней функции используйте простое логирование (стандартный модуль Python logging). Сделайте логирование внутри замыкания до вызова вашей функции calculate(operand1, operand2, action), в котором логируется информация о том какие операнды и какая арифметическая операция собираются поступить на вход функции calculate(operand1, operand2, action). Затем внутри того же closure следует сам вызов функции calculate(...). А затем, после этого вызова должно быть снова логирование, но уже с результатом выполнения вычисления, проделанного в этой функции.

Результат:

![image](https://github.com/user-attachments/assets/49a8502d-ae72-4ab6-9c78-a2ff48c4d5f1)

Результат(теста):

![image](https://github.com/user-attachments/assets/2a19f2c3-e337-409c-a6a4-c27f84ef98b4)

Результат теста Unit:

![image](https://github.com/user-attachments/assets/0e7b886b-a8d3-43c3-8522-9eee5418645d)

Результат теста Pytest:

![image](https://github.com/user-attachments/assets/da080898-c372-4b79-af80-0bd6fe42271d)

Программа реализует калькулятор, который выполняет базовые арифметические операции (сложение, вычитание, умножение, деление) между двумя числами.
Она использует декоратор для логирования всех вызовов функции calculate, отображая введённые операнды, выбранную операцию и результат вычисления. При делении на ноль программа возвращает сообщение об ошибке, а при некорректной операции уведомляет пользователя соответствующим сообщением. Основная функция main отвечает за взаимодействие с пользователем: запрашивает ввод данных и выводит результат вычисления.

1.3: Изучите основы каррирования. Каррирование в самом простом варианте - это создание специализированной функции на основе более общей функции с предустановленными параметрами для этой более общей функции. Реализуйте каррирование на примере вычисления количества радиоактивного вещества N, оставшегося в некоторый момент времени t от радокактивного вещества с периодом полураспада t1/2, если изначально это количество было равно N0. Закон распада задан формулой ... В качестве проставленного заранее параметра в данном примере должно быть значение периода полураспада t1/2, которое постоянно для каждого типа радиоактивного материала (радиоактивного изотопа химического элемента). Сделайте словарь, где в качестве колючей используются строки с символами радиоактивных изотопов, а в качестве значений им сопоставлены каррированные с характерными периодами полураспада. В основном коде вашей программы организуйте цикл по этому словарю и продемонстрируйте в нём вызовы каррированных функций с распечаткой на экране сколько вещества осталось от одного и того же N0 в некоторый момент времени t в зависимости от типа изотопа.

Результат:

![image](https://github.com/user-attachments/assets/5c74b384-d543-4a1d-84e9-6248168023ca)


Результат теста Unit:

![image](https://github.com/user-attachments/assets/3956e080-d649-4a93-a54b-52cbb81b3931)


Результат теста Pytest:

![image](https://github.com/user-attachments/assets/c969e82f-dc7a-4a5d-b828-abbbef27ba07)

Программа вычисляет остаточную массу радиоактивных изотопов на основе их периодов полураспада. С помощью функции decay_amount, она принимает начальную массу и время, затем рассчитывает, сколько вещества осталось для каждого изотопа: стронция-90, углерода-14 и кобальта-60. Результаты выводятся на экран, показывая остатки каждого изотопа после заданного периода времени.
